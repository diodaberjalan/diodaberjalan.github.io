<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Forensic Age Estimation Combiner</title>
  <!-- Updated Plotly CDN to explicit version v2.18.2 -->
  <script src="https://cdn.plot.ly/plotly-2.18.2.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .distribution {
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 8px;
    }
    h1, h2 {
      color: #333;
    }
    label {
      margin-right: 10px;
    }
    button {
      margin: 10px 0;
      padding: 8px 16px;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    select, input {
      margin: 5px;
    }
    #results {
      margin-top: 15px;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h1>Forensic Age Estimation Combiner (⁠✿⁠^⁠‿⁠^⁠)</h1>
  <p>This tool lets you add multiple age estimation methods, select their distribution type (Gaussian or Uniform), choose the combination method (Product or Union), and see the final combined distribution along with an estimation summary. Perfect for forensics combining different clues!</p>

  <div id="distributions-container">
    <!-- Pre-loaded distributions -->
    <div class="distribution" data-index="0">
      <h3>Method A</h3>
      <label>Type:
        <select class="dist-type">
          <option value="gaussian" selected>Gaussian</option>
          <option value="uniform">Uniform</option>
        </select>
      </label>
      <div class="params gaussian-params">
        <label>Mean: <input type="number" class="mean" value="20"></label>
        <label>Std Dev: <input type="number" class="std" value="5"></label>
      </div>
      <div class="params uniform-params" style="display:none;">
        <label>Min: <input type="number" class="min" value="0"></label>
        <label>Max: <input type="number" class="max" value="100"></label>
      </div>
    </div>
    <div class="distribution" data-index="1">
      <h3>Method B</h3>
      <label>Type:
        <select class="dist-type">
          <option value="uniform" selected>Uniform</option>
          <option value="gaussian">Gaussian</option>
        </select>
      </label>
      <div class="params gaussian-params" style="display:none;">
        <label>Mean: <input type="number" class="mean" value="30"></label>
        <label>Std Dev: <input type="number" class="std" value="5"></label>
      </div>
      <div class="params uniform-params">
        <label>Min: <input type="number" class="min" value="0"></label>
        <label>Max: <input type="number" class="max" value="100"></label>
      </div>
    </div>
  </div>
  
  <button id="add-distribution">Add New Distribution</button>
  
  <h2>Combination Settings</h2>
  <label>Combine using:
    <select id="combination-method">
      <option value="product">Product (Intersection)</option>
      <option value="union">Union (Mixture)</option>
    </select>
  </label>
  
  <br>
  <button id="calculate">Calculate Combined Distribution</button>
  
  <div id="plot" style="width:100%; height:500px;"></div>
  
  <div id="results"></div>
  
  <script>
    // Define probability density functions
    function gaussian(x, mean, std) {
      return Math.exp(-0.5 * Math.pow((x - mean) / std, 2)) / (std * Math.sqrt(2 * Math.PI));
    }
    
    function uniform(x, min, max) {
      return (x >= min && x <= max) ? 1 / (max - min) : 0;
    }
    
    // Toggle parameter inputs based on selected type
    function setupToggle(distributionDiv) {
      distributionDiv.querySelector('.dist-type').addEventListener('change', (e) => {
        const type = e.target.value;
        if (type === 'gaussian') {
          distributionDiv.querySelector('.gaussian-params').style.display = 'block';
          distributionDiv.querySelector('.uniform-params').style.display = 'none';
        } else {
          distributionDiv.querySelector('.gaussian-params').style.display = 'none';
          distributionDiv.querySelector('.uniform-params').style.display = 'block';
        }
      });
    }
    
    // Initialize toggles for pre-loaded distributions
    document.querySelectorAll('.distribution').forEach(setupToggle);
    
    // Add new distribution method
    document.getElementById('add-distribution').addEventListener('click', () => {
      const container = document.getElementById('distributions-container');
      const index = container.children.length;
      const div = document.createElement('div');
      div.className = 'distribution';
      div.setAttribute('data-index', index);
      div.innerHTML = `
        <h3>Method ${String.fromCharCode(65 + index)}</h3>
        <label>Type:
          <select class="dist-type">
            <option value="gaussian" selected>Gaussian</option>
            <option value="uniform">Uniform</option>
          </select>
        </label>
        <div class="params gaussian-params">
          <label>Mean: <input type="number" class="mean" value="30"></label>
          <label>Std Dev: <input type="number" class="std" value="5"></label>
        </div>
        <div class="params uniform-params" style="display:none;">
          <label>Min: <input type="number" class="min" value="0"></label>
          <label>Max: <input type="number" class="max" value="100"></label>
        </div>
      `;
      container.appendChild(div);
      setupToggle(div);
    });
    
    // Gather distribution data from the page
    function getDistributionData() {
      const container = document.getElementById('distributions-container');
      const distributions = [];
      container.querySelectorAll('.distribution').forEach(div => {
        const type = div.querySelector('.dist-type').value;
        if (type === 'gaussian') {
          const mean = parseFloat(div.querySelector('.mean').value);
          const std = parseFloat(div.querySelector('.std').value);
          distributions.push({ type: 'gaussian', mean, std });
        } else if (type === 'uniform') {
          const min = parseFloat(div.querySelector('.min').value);
          const max = parseFloat(div.querySelector('.max').value);
          distributions.push({ type: 'uniform', min, max });
        }
      });
      return distributions;
    }
    
    // Compute summary statistics and detect local maxima for modes
    function computeSummary(xValues, density, dx) {
      const total = density.reduce((sum, y) => sum + y * dx, 0);
      const normDensity = density.map(y => y / total);
      
      // Calculate mean
      let mean = 0;
      normDensity.forEach((y, i) => { mean += xValues[i] * y * dx; });
      
      // Calculate variance
      let variance = 0;
      normDensity.forEach((y, i) => { variance += Math.pow(xValues[i] - mean, 2) * y * dx; });
      const std = Math.sqrt(variance);
      
      // Detect local maxima for mode estimation
      const modes = [];
      for (let i = 1; i < normDensity.length - 1; i++) {
        if (normDensity[i] > normDensity[i - 1] && normDensity[i] > normDensity[i + 1]) {
          modes.push({ x: xValues[i], density: normDensity[i] });
        }
      }
      
      return { mean, std, modes };
    }
    
    // Color palette for methods (each gets a distinct color)
    const methodColors = [
      'rgba(31, 119, 180, 0.5)', // blue
      'rgba(255, 127, 14, 0.5)', // orange
      'rgba(44, 160, 44, 0.5)',  // green
      'rgba(214, 39, 40, 0.5)',  // red
      'rgba(148, 103, 189, 0.5)' // purple
    ];
    
    // Calculate and plot distributions with updated styling
    function calculateAndPlot() {
      const distributions = getDistributionData();
      const combinationMethod = document.getElementById('combination-method').value;
      
      // Define x-axis with a finer resolution for accuracy (0 to 100 with 0.1 step)
      const xValues = [];
      const step = 0.1;
      for (let x = 0; x <= 100; x += step) {
        xValues.push(x);
      }
      
      const curves = [];
      
      // Plot individual distributions with distinct colors and transparent lines
      distributions.forEach((dist, idx) => {
        const color = methodColors[idx % methodColors.length];
        const y = xValues.map(x => {
          return dist.type === 'gaussian'
            ? gaussian(x, dist.mean, dist.std)
            : uniform(x, dist.min, dist.max);
        });
        curves.push({
          x: xValues,
          y: y,
          mode: 'lines',
          name: 'Method ' + String.fromCharCode(65 + idx),
          line: { width: 2, color: color }
        });
      });
      
      // Compute combined distribution
      let combinedY = xValues.map(() => (combinationMethod === 'product' ? 1 : 0));
      if (combinationMethod === 'product') {
        distributions.forEach(dist => {
          combinedY = combinedY.map((prev, i) => {
            const x = xValues[i];
            const yVal = dist.type === 'gaussian'
              ? gaussian(x, dist.mean, dist.std)
              : uniform(x, dist.min, dist.max);
            return prev * yVal;
          });
        });
      } else if (combinationMethod === 'union') {
        distributions.forEach(dist => {
          xValues.forEach((x, i) => {
            const yVal = dist.type === 'gaussian'
              ? gaussian(x, dist.mean, dist.std)
              : uniform(x, dist.min, dist.max);
            combinedY[i] += yVal;
          });
        });
        combinedY = combinedY.map(y => y / distributions.length);
      }
      
      // Normalize the combined distribution
      const area = combinedY.reduce((sum, y) => sum + y * step, 0);
      combinedY = combinedY.map(y => y / area);
      
      // Add combined distribution with a solid black line
      curves.push({
        x: xValues,
        y: combinedY,
        mode: 'lines',
        name: 'Combined Distribution',
        line: { width: 2, color: 'black' }
      });
      
      // Compute summary statistics
      const summary = computeSummary(xValues, combinedY, step);
      let summaryText = `<strong>Estimation Summary:</strong><br>
                         Mean: ${summary.mean.toFixed(2)} years, Std Dev: ${summary.std.toFixed(2)} years<br>`;
      if (summary.modes.length === 0) {
        summaryText += `Mode: Not detected`;
      } else if (summary.modes.length === 1) {
        summaryText += `Mode: ${summary.modes[0].x.toFixed(2)} years`;
      } else {
        summaryText += `Modes: ${summary.modes.map(m => m.x.toFixed(2)).join(', ')} years`;
      }
      
      document.getElementById('results').innerHTML = summaryText;
      
      Plotly.newPlot('plot', curves, { 
        title: 'Age Distribution Estimations', 
        xaxis: { title: 'Age (years)' }, 
        yaxis: { title: 'Probability Density' },
        margin: { t: 40 }
      });
    }
    
    document.getElementById('calculate').addEventListener('click', calculateAndPlot);
  </script>
</body>
</html>
